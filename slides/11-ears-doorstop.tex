\documentclass[aspectratio=169]{beamer}
\usepackage{etex} % fixes new-dimension error

\input{macros/beamerconf}
\input{macros/preamble}
\input{macros/macros}

\lstdefinelanguage{EARS}{
  sensitive=true,
  belowskip=-0.5em,
  frame=none,
  basicstyle=\ttfamily,
  keywords=[1]{if,then,while,when,where},
  keywordstyle=[1]\bfseries\color{green!40!black},
  keywords=[2]{the,shall},
  keywordstyle=[2]\bfseries\color{purple!40!black},
}

\colorlet{mygreen}{green!40!black}
\colorlet{mypurple}{purple!40!black}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Command for EARS patterns %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Pattern for generic requirements
\newcommand{\earsg}[4]{{\bf \color{mygreen}while} {#1} {\bf \color{mygreen}when} {#2} %
                      {\bf \color{mypurple}the} {#3} {\bf \color{mypurple}shall} {#4}}
%% Pattern for ubiquitous requirements
\newcommand{\earsu}[2]{{\bf \color{mypurple}the} {#1} {\bf \color{mypurple}shall} {#2}}
%% Pattern for event driven requirements
\newcommand{\earse}[3]{{\bf \color{mygreen}when} {#1} {\bf \color{mypurple}the} {#2} {\bf \color{mypurple}shall} {#3}}
%% Pattern for state based requirements
\newcommand{\earss}[3]{{\bf \color{mygreen}while} {#1} {\bf \color{mypurple}the} {#2} {\bf \color{mypurple}shall} {#3}}
%% Pattern for optional feature requirements
\newcommand{\earso}[3]{{\bf \color{mygreen}where} {#1} {\bf \color{mypurple}the} {#2} {\bf \color{mypurple}shall} {#3}}
%% Pattern for unwanted requirements
\newcommand{\earsw}[3]{{\bf \color{mygreen}if} {#1} {\bf \color{mygreen}then} {\bf \color{mypurple}the} {#2} {\bf \color{mypurple}shall} {#3}}

\setLecture{11}{More on Requirements: The EARS approach and the Doorstop tool}

\begin{document}

\frame[plain]{\titlepage}

\section*{The EARS Approach to Requirements Specification}

\begin{frame}[shrink]
  \small
  \frametitle{Getting to Know EARS}
  \begin{block}{What is EARS?}
  \begin{itemize}
    \item The acronym {\bf EARS} stands for {\it "Easy Approach to Requirements Syntax"} 
    \item EARS is a mechanism to gently constrain textual requirements
    \item EARS patterns provide structured guidance that enable authors to write high quality textual requirements.
  \end{itemize}
  \end{block}
\end{frame}

\begin{frame}
  \frametitle{Some history on the origins and motivations for proposing EARS}
  \begin{block}{Main aspects}
  \begin{itemize}
    \item Alistair Mavin and colleagues faced a challenge when working at Rolls Royce and developing a XXX and (i) find the real requirements to the problem at hand, (ii) organize them, (iii) refine them, (iv) fill in the gaps 
    \item moreover, the management required that the elicited should be clear, concise, testable, traceable, and correct
    \item overall the objectives set where that (i) significantly reduce requirement errors when compared to previous projects, (ii) reducing those errors that became implementation errors, (iii) and minimize the error mitigation costs   
  \end{itemize}
  
  \end{block}

\end{frame}

\begin{frame}

\begin{block}{EARS Building Blocks}
  \begin{itemize}
    \item There is a set syntax (structure), with an underlying ruleset. 
    \item A small number of keywords are used to denote the different clauses of an EARS requirement. 
    \item The clauses are always in the same order, following temporal logic. 
    \item The syntax and the keywords closely match common usage of English and are therefore intuitive.
  \end{itemize}  
\end{block}

\end{frame}


\begin{frame}
  \small
  \frametitle{How EARS Came to Life}
  \begin{block}{Context}
  \begin{itemize}
    \item Ideas triggered while the author and colleagues at Rolls-Royce PLC were analysing the airworthiness regulations for an engine jet control system. 
    \item The regulations contained high level objectives, a mixture of implicit and explicit requirements at different levels, lists, guidelines and supporting information.
    \item In the process of extracting and simplifying the requirements, Mav noticed that the requirements all followed a similar structure.
    \item He found that requirements were easiest to read when the clauses always appeared in the same order. These patterns were refined and evolved to create EARS.
    \item The notation was first published in 2009 and has been adopted by many organisations across the world.
  \end{itemize}
  \end{block}
  
\end{frame}

\begin{frame}
  \frametitle{Motivations for Adopting EARS (1/2)}
  \begin{block}{Why adopt EARS?}
  \begin{itemize}
  \item  System requirements are usually written in unconstrained natural language, which is inherently imprecise. 
  \item Often, requirements authors are not trained in how to write requirements. 
  \item During system development, requirements problems propagate to lower levels. 
  \end{itemize}
  {\bf This creates unnecessary volatility and risk, impacting programme schedule and cost.}
  \end{block} 
\end{frame}

\begin{frame}
  \frametitle{Motivations for Adopting EARS (2/2)}
  \begin{block}{Why adopt EARS?}
  \begin{itemize}
    \item EARS reduces or even eliminates common problems found in natural language requirements. 
    \item It is especially effective for requirements authors who must write requirements in English, but whose first language is not English. 
    \item EARS has proved popular with practitioners because it is lightweight, there is little training overhead, no specialist tool is necessary, and the resultant requirements are easy to read.
  \end{itemize}
  \end{block} 
\end{frame}

\begin{frame}
  \frametitle{Who is using EARS?}
  \begin{block}{WHO USES EARS?}
  \begin{itemize}
    \item the EARS methodology was first presented to the 17th IEEE International Requirements Engineering Conference in 2009
    \item Since then, it has been adopted by numerous organizations (Bosch, Honeywell, Intel, Rolls-Royce and Siemens) and included in the requirements engineering curricula of many universities (China, France, Sweden, UK, USA, and now Portugal :-)).  
  \end{itemize}
  In the words of the author, "(...) because the EARS method imposes just a slight constraint on natural language while providing a simple, logical method for constructing clear, concise, unambiguous requirements."
  \end{block} 
\end{frame}

\section*{The EARS Patterns}

\begin{frame}
  \frametitle{EARS Patterns - Overview}  
  Adicionar aqui texto generico, e.g., quantos padroes, etc., etc.
\end{frame}

\begin{frame}[fragile]
  \frametitle{The EARS Patterns - Ubiquitous Requirements}
  \begin{block}{Ubiquitous requirements}
    These refer to requirements that are always active. 
    \begin{lstlisting}[language=EARS]
               the <system name> shall <system response>
    \end{lstlisting}
    Moreover:
    \begin{itemize}
    \item typically state fundamental aspects of the system
    \item No EARS specific keyword is present when specifying this particular type of requirement.\\
    
    \item Which makes sense! These requirements do not depends on pre-condition(s) or triggers to become active. They must remain active all the time.
    \end{itemize}
  \end{block}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Ubiquitous Requirements Examples}
  \begin{example}
  \begin{itemize}
    \item \earsu{distances computed between two sets of coordinates}{account for curvature of the earth}    
    \item \earsu{compiler}{transform source code into semantically equivalent binary code}
    \item \earsu{surveillance UAV}{fly only inside of the designated flight zone}
    \item \earsu{software package}{contain an installer}
    \item \earsu{software}{be written in programming language X}
  \end{itemize}
  \end{example}
\end{frame}

%Distances computed between two sets of coordinates shall account for curvature of the earth.

\begin{frame}[fragile]
 \frametitle{THE EARS Patterns - State Driven Requirements}
 \begin{block}{State driven requirements}
  These are requirements that are active as long as the specified state, hereby represented by a pre-condition, remains true. These requirements start with the keyword while.
  \begin{lstlisting}[language=EARS]
   while <precondition(s)> the <system name> shall <system response>
  \end{lstlisting}  
  \end{block}
\end{frame}


\begin{frame}
  \frametitle{Examples of State Driven Requirements}
  \begin{example}
  \begin{itemize}
    \item \earss{there is no card in the ATM}{ATM}{display "insert card to begin"}.
    \item \earss{in maintenance mode}{kitchen system}{reject all input}.
    \item \earss{in Low Power Mode}{software}{keep the display brightness at the Minimum Level}
    \item \earss{the heater is on}{software}{close the water intake valve}
    \item \earss{the autopilot is engaged}{software}{display a visual indication to the pilot}
  \end{itemize}
 \end{example}
\end{frame}

\begin{frame}[fragile]
 \frametitle{THE EARS Patterns - Event Driven Requirements}
 \begin{block}{Event driven requirements}
  Event driven requirements specify how a system must respond when a triggering event occurs and are denoted by the keyword {\bf \color{mygreen} when}.
  
  Event driven requirementsAre initiated {\bf when and only when} a trigger occurs or is detected.
 \end{block}
 \begin{block}{Syntactic pattern}
  \begin{lstlisting}[language=EARS]
        when <trigger> the <system name> shall <system response>
  \end{lstlisting}
 \end{block}
 \begin{block}{}
   
 \end{block}

\end{frame}  

\begin{frame}
  \frametitle{Examples of Event Driven Requirements}
   \begin{example}
   \begin{itemize}
     \item \earse{mute is selected}{laptop}{suppress all audio output}.
     \item \earse{potato is inserted into the input hatch}{kitchen system}{peel the potato}.
     \item \earse{continuous ignition is commanded by the aircraft}{control system}{switch oncontinuous ignition}
     \item \earse{an unregistered device is plugged into a USB port}{OS}{tries to locate and load the driver for the device.}
     \item \earse{the water level falls below the Low Water Threshold}{software}{open the water valve
to fill the tank to the High Water Threshold}
   \end{itemize}
   \end{example}
%   \pause
%   \begin{block}{Simple translation exercise}
%   \begin{description}
%     \item [Original req:] In the event of a fire, the security system shall Unlock the fire escape doors
%     \item [In EARS:] \pause \earse{a fire is detected }{security system}{unlock the fire escape doors}
%   \end{description}
%   \end{block}


\end{frame}

%When Continuous_Ignition is commanded by the Aircraft, the Control_System shall switch on%Continuous_Ignition.%In the event of a fire, the Security_System shall Unlock the Fire_Escape_Doors.

\begin{frame}[fragile]
  \frametitle{THE EARS Patterns - Optional feature requirements}
  \begin{block}{Optional feature requirements}
   Optional feature requirements apply in products or systems that include the specified feature and are denoted by the keyword Where.
  \begin{lstlisting}[language=EARS]
 where <feature is included> the <system name> shall <system response>
     \end{lstlisting}
   \end{block}
\end{frame}


\begin{frame}[fragile]
 \frametitle{THE EARS Patterns - Optional feature requirements}
  \begin{example}
  \begin{itemize}
   \item \earso{the car has a sunroof}{car}{have a sunroof control panel on the driver door}.
   \item \earso{the kitchen system has a food freshness sensor}{kitchen system}{detect rotten foodstuffs}. 
   \item \earso{a thesaurus is part of the software package}{installer}{prompt the user before installing the thesaurus}
   \item \earso{hardware encryption is installed}{software}{encrypt data using the hardware instead of using a software algorithm}
   \item \earso{a HDMI port is present}{software}{allow the user to select HD content for viewing}
  \end{itemize}
  \end{example}
\end{frame}



\begin{frame}[fragile]
 \frametitle{THE EARS Patterns - Unwanted behaviour requirements}
  \begin{block}{Unwanted behaviour requirements}
  These are used to specify the required system response to undesired situations and are denoted by the keywords If and Then.
   \begin{lstlisting}[language=EARS]
               if <unwanted trigger or event> then 
             the <system name> shall <system response> 
   \end{lstlisting}
  \end{block}
\end{frame}  


\begin{frame}
  \frametitle{THE EARS Patterns - Unwanted behaviour requirements}
  \begin{example}
   \begin{itemize}
    \item \earsw{an invalid credit card number is entered}{website}{display "please re-enter credit card details"}
    \item \earsw{a spoon is inserted to the input hatch}{kitchen system}{eject the spoon}
    \item \earsw{the memory checksum is invalid}{software}{display an error message}
    \item \earsw{the ATM card inserted is reported lost or stolen}{software}{confiscate the card}
    \item \earsw{the measured and calculated speeds vary by more than
10\%}{software}{use the measured speed}
   \end{itemize}
  \end{example}
\end{frame}


\begin{frame}[fragile]
  \frametitle{EARS Patterns - Complex Requirement Pattern}
  \begin{block}{Syntax of a complex EARS requirement}
    Is the more general pattern of requirement that exists in EARS. It uses a combination of EARS keywords to allow for such complexity.
    \begin{lstlisting}[language=EARS]
    <multiple conditions> the <system name> shall <system response>  
    \end{lstlisting}
    such that {\tt multiple conditions} is a combination of:
    \begin{itemize}
      \item a pre-condition, using the {\bf \color{mygreen} while} keyword
      \item a trigger, using the {\bf \color{mygreen} when} keyword
      \item an unwanted condition, using the {\bf \color{mygreen} if} keyword
      \item a specific feature, using the {\bf \color{mygreen} where} keyword
    \end{itemize}
  \end{block}
\end{frame}

\begin{frame}[fragile]
 \frametitle{THE EARS Patterns - Example of Complex Requirements}
  \begin{example}
  \begin{itemize}
  \item \earsg{the aircraft is on ground}{reverse thrust is commanded}{engine control system}{enable reverse thrust}
  \item \earsg{a second optical drive is installed}{the user selects to copy disks}{software}{display an option to copy directly from one optical drive to the other optical}
  \item \earsg{in start up mode}{the software detects an external flash card}{software}{use the external
flash card to store photos}
  \item {\bf \color{mygreen}when} the landing gear button is depressed once \earsw{the software detects that the landing gear does not lock into position}{software}{sound an alarm}
  \end{itemize}
  \end{example}
\end{frame}

\section*{How to apply EARS patterns}

\begin{slide}{THE EARS PATTERNS}
  \begin{itemize}
  \item Identify whether you are working with a requirement, or something else (e.g., note, example, remark, etc)
  \item Identify compound requirements, i.e., whether the requirement needs to be split/decomposed 
  \item Identify the acting system, person, or process
  \item Analise the needed sentence type(s)
  \item Identigy possible missing requirements
  \item Analyse the translated requirements for ambiguity, conflict, and repetition
  \item Review requirements if possible
  \item Interate as required
  \end{itemize}
\end{slide}
%
%\section*{Troubleshooting EARS problems}
%
%\begin{frame}
%  \frametitle{What are the issues that can occur when using EARS?}
%  \begin{itemize}
%  \item {\it No sentence type fits:} Maybe you are not translating a requirement?
%  \item {\it Can't identify the actor:} either use higher abstraction level until it makes sense, or get more information from the relevant stakeholder
%  \item {\it There is no system response:}  typically the case with non-functional requirements; it can be expressed as "the system shall be ..."
%  \item {\it There is no template for "shall not":} try using "shall be immune" or similar or, as last resort, use the "shall not" pattern
%  \item {\it EARS produces too many atomic requirements:} 
%  \end{itemize}
%  
%\end{frame}
%
%\section*{The Doorstop Tool}
%
%
%\begin{frame}
%  \frametitle{What is Doorstop?}
%  \begin{block}{Motivations for Doorstop}
%  \begin{itemize}
%    \item Effectively managing the requirements and traceability in a complex software project can be a
%challenging task
%    \item Many tools exist to support the initial creation and management of changes to
%text-based requirements.
%    \item The most popular commercial solutions use a centralized server to host
%a database with a front-end desktop or web interface
%    \item {\bf }
%  \end{itemize}
%  
%  \end{block}
%
%   
%\end{frame}
%
%\begin{frame}
%  \frametitle{What is Doorstop?}
%  \begin{block}{In a Nutshell}
%  \begin{itemize}
%    \item Doorstop is both a Python tool and API that allows to write requirements in a text based manner and that uses version control. 
%    \item This solution allows a project to utilize its existing development tools to manage versions of the requirements using a lightweight, developer-friendly interface.
%  \end{itemize}
%  \end{block}
%  \begin{block}{How it works (high-level description)}
%  \begin{itemize}
%  \item When a project leverages this tool, each linkable item (requirement, test case, etc.) is stored as a YAML file in a designated directory. 
%  \item The items in each directory form a document.
%  \item The relationship between documents forms a tree hierarchy.
%  \item Doorstop provides mechanisms for modifying this tree, validating item traceability, and publishing documents in several formats.  
%  \end{itemize}
%
%       
%  \end{block}
%
%  
%\end{frame}
%


\end{document}
