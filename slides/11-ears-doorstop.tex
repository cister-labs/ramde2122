\documentclass[aspectratio=169]{beamer}
\usepackage{etex} % fixes new-dimension error

\input{macros/beamerconf}
\input{macros/preamble}
\input{macros/macros}


\setLecture{11}{More on Requirements: The EARS approach and the Doorstop tool}

\begin{document}

\frame[plain]{\titlepage}

\section*{The EARS Approach to Requirements Specification}

\begin{frame}[shrink]
  \small
  \frametitle{Getting to Know EARS}
  \begin{block}{What is EARS?}
  \begin{itemize}
    \item The acronym {\bf EARS} stands for {\it "Easy Approach to Requirements Syntax"} 
    \item EARS is a mechanism to gently constrain textual requirements
    \item EARS patterns provide structured guidance that enable authors to write high quality textual requirements.
  \end{itemize}
  \end{block}
\end{frame}

\begin{frame}
  \frametitle{Some history on the origins and motivations for proposing EARS}
  \begin{block}{Main aspects}
  \begin{itemize}
    \item Alistair Mavin and colleagues faced a challenge when working at Rolls Royce and developing a XXX and (i) find the real requirements to the problem at hand, (ii) organize them, (iii) refine them, (iv) fill in the gaps 
    \item moreover, the management required that the elicited should be clear, concise, testable, traceable, and correct
    \item overall the objectives set where that (i) significantly reduce requirement errors when compared to previous projects, (ii) reducing those errors that became implementation errors, (iii) and minimize the error mitigation costs   
  \end{itemize}
  
  \end{block}

\end{frame}

\begin{frame}

\begin{block}{EARS Building Blocks}
  \begin{itemize}
    \item There is a set syntax (structure), with an underlying ruleset. 
    \item A small number of keywords are used to denote the different clauses of an EARS requirement. 
    \item The clauses are always in the same order, following temporal logic. 
    \item The syntax and the keywords closely match common usage of English and are therefore intuitive.
  \end{itemize}  
\end{block}

\end{frame}


\begin{frame}
  \small
  \frametitle{How EARS Came to Life}
  \begin{block}{Context}
  \begin{itemize}
    \item Ideas triggered while the author and colleagues at Rolls-Royce PLC were analysing the airworthiness regulations for an engine jet control system. 
    \item The regulations contained high level objectives, a mixture of implicit and explicit requirements at different levels, lists, guidelines and supporting information.
    \item In the process of extracting and simplifying the requirements, Mav noticed that the requirements all followed a similar structure.
    \item He found that requirements were easiest to read when the clauses always appeared in the same order. These patterns were refined and evolved to create EARS.
    \item The notation was first published in 2009 and has been adopted by many organisations across the world.
  \end{itemize}
  \end{block}
  
\end{frame}

\begin{frame}
  \frametitle{Motivations for Adopting EARS (1/2)}
  \begin{block}{Why adopt EARS?}
  \begin{itemize}
  \item  System requirements are usually written in unconstrained natural language, which is inherently imprecise. 
  \item Often, requirements authors are not trained in how to write requirements. 
  \item During system development, requirements problems propagate to lower levels. 
  \end{itemize}
  {\bf This creates unnecessary volatility and risk, impacting programme schedule and cost.}
  \end{block} 
\end{frame}

\begin{frame}
  \frametitle{Motivations for Adopting EARS (2/2)}
  \begin{block}{Why adopt EARS?}
  \begin{itemize}
    \item EARS reduces or even eliminates common problems found in natural language requirements. 
    \item It is especially effective for requirements authors who must write requirements in English, but whose first language is not English. 
    \item EARS has proved popular with practitioners because it is lightweight, there is little training overhead, no specialist tool is necessary, and the resultant requirements are easy to read.
  \end{itemize}
  \end{block} 
\end{frame}

\begin{frame}
  \frametitle{Who is using EARS?}
  \begin{block}{WHO USES EARS?}
  \begin{itemize}
    \item the EARS methodology was first presented to the 17th IEEE International Requirements Engineering Conference in 2009
    \item Since then, it has been adopted by numerous organizations (Bosch, Honeywell, Intel, Rolls-Royce and Siemens) and included in the requirements engineering curricula of many universities (China, France, Sweden, UK, USA, and now Portugal :-)).  
  \end{itemize}
  In the words of the author, "(...) because the EARS method imposes just a slight constraint on natural language while providing a simple, logical method for constructing clear, concise, unambiguous requirements."
  \end{block} 
\end{frame}

\section*{The EARS Patterns}

%<<<<<<< HEAD
\begin{frame}[fragile]
  \frametitle{EARS Patterns}
  \begin{block}{Syntax of a generic EARS syntax}
    \begin{verbatim}
    While <pre-condition(s)>, 
     when <trigger>, 
      the <system name> shall <system response>  
    \end{verbatim}
    such that:
    \begin{itemize}
      \item a {\tt pre-condition} defines a condition that must be true in order for a requirement to be active
      \item a {\tt trigger} is a discrete event that when detected makes the requirement active
      \item {\tt system name} is the name of the concrete (sub{-})system 
    \end{itemize}
  \end{block}
%  The EARS ruleset states that a requirement must have: Zero or many preconditions; Zero or one trigger; One system name; One or many system responses.

%The application of the EARS notation produces requirements in a small number of patterns, depending on the clauses that are used. The patterns are illustrated below.
\end{frame}

\begin{frame}[fragile]
  \frametitle{The EARS Patterns}
  \begin{block}{Ubiquitous requirements}
    These refer to requirements that are always active. 
    \begin{center}
    The {\color{red}{$<$system name$>$}} shall {\color{blue}{$<$system response$>$}}
    \end{center}
    No EARS specific keyword is present when specifying this particular type of requirement.
  \end{block}
%=======
% \begin{frame}[fragile]
%   \frametitle{THE EARS PATTERNS}
%   \begin{block}{Generic EARS syntax}
%     The clauses of a requirement written in EARS always appear in the same order. The basic structure of an EARS requirement is:
%     \begin{verbatim}
%     While <optional pre-condition>, 
%      when <optional trigger>, 
%       the <system name> shall <system response>  
%     \end{verbatim}
%   The EARS ruleset states that a requirement must have: Zero or many preconditions; Zero or one trigger; One system name; One or many system responses.

% The application of the EARS notation produces requirements in a small number of patterns, depending on the clauses that are used. The patterns are illustrated below.
%   \end{block}
% \end{frame}

% \begin{frame}[fragile]
%   \frametitle{The EARS Patterns}
%   \begin{block}{Ubiquitous requirements}
%     These refer to requirements that are always active. No EARS specific keyword is present when specifying this particular type of requirement.
    
%     The pattern for 
%     \begin{verbatim}
%     The <system name> shall <system response>  
%     \end{verbatim}
%   \end{block}
%   \begin{example}
%     \begin{itemize}
%       \item The mobile phone shall have a mass of less than XX grams.
%       \item The kitchen system shall have an input hatch
%     \end{itemize}
%   \end{example}
% \end{frame}


% \begin{frame}[fragile]
%   \frametitle{THE EARS PATTERNS}
%   \begin{block}{State driven requirements}
%   State driven requirements are active as long as the specified state remains true and are denoted by the keyword While.
%     \begin{verbatim}
%       While <precondition(s)>, 
%        the <system name> 
%         shall <system response>
%     \end{verbatim}  
%   \end{block}
  
%   \begin{example}
%   \begin{itemize}
%     \item While there is no card in the ATM, the ATM shall display â€œinsert card to begin.
%     \item While the kitchen system is in maintenance mode, the kitchen system shall reject all input.
%   \end{itemize}
%   \end{example}

% \end{frame}

% \begin{frame}[fragile]
%   \frametitle{THE EARS PATTERNS}
%   \begin{block}{Event driven requirements}
%   Event driven requirements specify how a system must respond when a triggering event occurs and are denoted by the keyword When.
%     \begin{verbatim}
%       When <trigger>, 
%         the <system name> 
%          shall <system response>
%     \end{verbatim}
%   \end{block}
  
%   \begin{example}
%   \begin{itemize}
%     \item When mute is selected, the laptop shall suppress all audio output.
%     \item When the chef inserts potato to the input hatch, the kitchen system shall peel the potato.
%   \end{itemize}
%   \end{example}
% \end{frame}



% \begin{frame}[fragile]
%   \frametitle{THE EARS PATTERNS}
%   \begin{block}{Optional feature requirements}
%   Optional feature requirements apply in products or systems that include the specified feature and are denoted by the keyword Where.
%     \begin{verbatim}
%       Where <feature is included>, 
%        the <system name> 
%         shall <system response>
%     \end{verbatim}
%   \end{block}
  
%   \begin{example}
%   \begin{itemize}
%     \item Where the car has a sunroof, the car shall have a sunroof control panel on the driver door.
%     \item Where the kitchen system has a food freshness sensor, the kitchen system shall detect rotten foodstuffs. 
%   \end{itemize}
%   \end{example}
% \end{frame}



% \begin{frame}[fragile]
%   \frametitle{THE EARS PATTERNS}
%   \begin{block}{Unwanted behaviour requirements}
%     These are used to specify the required system response to undesired situations and are denoted by the keywords If and Then.
%     \begin{verbatim}
%      If <trigger>, 
%       then the <system name> 
%        shall <system response> 
%     \end{verbatim}
%       \end{block}
  
%   \begin{example}
%   \begin{itemize}
%     \item If an invalid credit card number is entered, then the website shall display "please re-enter credit card details"
%     \item  If a spoon is inserted to the input hatch, then the kitchen system shall eject the spoon.
%   \end{itemize}
%   \end{example}
% \end{frame}



% \begin{frame}[fragile]
%   \frametitle{THE EARS PATTERNS}
%   \begin{block}{Complex requirements}
%   The simple building blocks of the EARS patterns described above can be combined to specify requirements for richer system behaviour. Requirements that include more than one EARS keyword are called Complex requirements.
%     \begin{verbatim}
%      While <precondition(s)>, 
%       When <trigger>, 
%        the <system name> shall <system response> 
%     \end{verbatim}
%     Example: While the aircraft is on ground, when reverse thrust is commanded, the engine control system shall enable reverse thrust.

% Complex requirements for unwanted behaviour also include the If-Then keywords.
%   \end{block}

% \end{frame}


\newcommand{\mkw}[2]{\textcolor{#2}{\textbf{#1}}\xspace}
\newcommand{\ewhile}{\mkw{while}{pink!75!black}}
\newcommand{\ewhere}{\mkw{where}{pink!75!black}}
\newcommand{\eif}{\mkw{if}{pink!75!black}}
\newcommand{\ethen}{\mkw{then}{pink!75!black}}
\newcommand{\ewhen}{\mkw{when}{blue!75!black}}
\newcommand{\ethe}{\mkw{the}{purple!75!black}}
\newcommand{\eshall}{\mkw{shall}{red!75!black}}

\begin{slide}{Generic EARS syntax}
    The clauses of a requirement written in EARS always appear in the same order. The basic structure of an EARS requirement is:

    \begin{block}{}\ttfamily
    \ewhile <optional pre-condition>, \\
     \ewhen <optional trigger>, \\
      \ethe <system name> \eshall <system response> 
    \end{block}

  The EARS ruleset states that a requirement must have: Zero or many preconditions; Zero or one trigger; One system name; One or many system responses.

The application of the EARS notation produces requirements in a small number of patterns, depending on the clauses that are used. The patterns are illustrated below.
\end{slide}

\begin{slide}{Ubiquitous requirements}
    These refer to requirements that are always active. No EARS specific keyword is present when specifying this particular type of requirement.
    
    The pattern for 
    \begin{block}{}
    \ethe <system name> \eshall <system response>  
    \end{block}
%>>>>>>> ef03fff95784903be0e9f73a26dbf780eb84f02a
  \begin{example}
    \begin{itemize}
      \item The {\color{red}{mobile phone}} shall {\color{blue}{have a mass of less than $x$ grams}}.
      \item The {\color{red}kitchen system} shall {\color{blue}{have an input hatch}}.
    \end{itemize}
  \end{example}
\end{slide}


<<<<<<< HEAD
\begin{frame}[fragile]
  \frametitle{THE EARS PATTERNS}
  \begin{block}{State driven requirements}
  State driven requirements are active as long as the specified state remains true.
    \begin{center}
      While {\color{orange}{$<$pre-condition(s)$>$}} the {\color{red}{$<$system name$>$}} shall {\color{blue}{$<$system response$>$}}
    \end{center}  
  \end{block}
=======
\begin{slide}{State driven requirements}
  State driven requirements are active as long as the specified state remains true and are denoted by the keyword While.
    \begin{block}{}
      \ewhile <precondition(s)>,\\
       \ethe <system name> \\
        \eshall <system response>
    \end{block}  
>>>>>>> ef03fff95784903be0e9f73a26dbf780eb84f02a
  
  \begin{example}
  \begin{itemize}
    \item While {\color{orange}{there is no card in the ATM}} the {\color{red}{ATM}} shall {\color{blue}{display "insert card to begin"}}.
    \item While {\color{orange}{in maintenance mode}}, the {\color{red}{kitchen system}} shall {\color{blue}{reject all input}}.
  \end{itemize}
  \end{example}

\end{slide}

<<<<<<< HEAD
\begin{frame}[fragile]
  \frametitle{THE EARS Patterns}
  \begin{block}{Event driven requirements}
  Event driven requirements specify how a system must respond when a triggering event occurs and are denoted by the keyword When.
    \begin{center}
      When <trigger> the <system name> shall <system response>
    \end{center}
  \end{block}
=======
\begin{slide}{Event driven requirements}
  Event driven requirements specify how a system must respond when a triggering event occurs and are denoted by the keyword When.
    \begin{block}{}
      \ewhen <trigger>, \\
        \ethe <system name> \\
         \eshall <system response>
    \end{block}
>>>>>>> ef03fff95784903be0e9f73a26dbf780eb84f02a
  
  \begin{example}
  \begin{itemize}
    \item When mute is selected, the laptop shall suppress all audio output.
    \item When the chef inserts potato to the input hatch, the kitchen system shall peel the potato.
  \end{itemize}
  \end{example}
\end{slide}



\begin{slide}{Optional feature requirements}
  Optional feature requirements apply in products or systems that include the specified feature and are denoted by the keyword Where.
<<<<<<< HEAD
    \begin{center}
      Where <feature is included>, 
       the <system name> 
        shall <system response>
    \end{center}
  \end{block}
=======
    \begin{block}{}
      \ewhere <feature is included>, \\
       \ethe <system name> \\
        \eshall <system response>
    \end{block}
>>>>>>> ef03fff95784903be0e9f73a26dbf780eb84f02a
  
  \begin{example}
  \begin{itemize}
    \item Where the car has a sunroof, the car shall have a sunroof control panel on the driver door.
    \item Where the kitchen system has a food freshness sensor, the kitchen system shall detect rotten foodstuffs. 
  \end{itemize}
  \end{example}
\end{slide}



\begin{slide}{Unwanted behaviour requirements}
    These are used to specify the required system response to undesired situations and are denoted by the keywords If and Then.
    \begin{block}{}
     \eif <trigger>, \ethen\\
     \ethe <system name> \\
       \eshall <system response>
    \end{block}
      
  \begin{example}
  \begin{itemize}
    \item If an invalid credit card number is entered, then the website shall display "please re-enter credit card details"
    \item  If a spoon is inserted to the input hatch, then the kitchen system shall eject the spoon.
  \end{itemize}
  \end{example}
\end{slide}



\begin{slide}{Complex requirements}
  The simple building blocks of the EARS patterns described above can be combined to specify requirements for richer system behaviour. Requirements that include more than one EARS keyword are called Complex requirements.
    \begin{block}{}
     \ewhile <precondition(s)>, \\
      \ewhen <trigger>, \\
       \ethe <system name> \eshall <system response>
    \end{block}
    Example: While the aircraft is on ground, when reverse thrust is commanded, the engine control system shall enable reverse thrust.

Complex requirements for unwanted behaviour also include the If-Then keywords.
\end{slide}


%%%%%%%%%%%%%%

\begin{slide}{Formalise requirements}

  \doExercise{Write the following using FOL}{
    % \vspace*{-7mm}
    Assume predicates \texttt{isMobile, hasMass, isKitchen, hasInputHatch}.
    \begin{enumerate}
      \item \ethe mobile phone \eshall have a mass of less than XX grams.
      % exists ph,m . isMobile(ph) and hasMass(ph,m) and m<XX
      \item \ethe kitchen system \eshall have an input hatch
      % exists k. isKitchen(k) and hasInputHatch(k)
    \end{enumerate}
  }

  \doExercise{Write the following using Modal Logic}{
    % \vspace*{-7mm}
    Assume $MOD = 1$ (singleton) and $PROP = \{atmHasCard, atmAsksForCard, kitchenInMaintenance, kitchenRejInput\}$
    \begin{enumerate}
    \item \ewhile there is no card in the ATM, \ethe ATM \eshall display ``insert card to begin''.
    % [] !hasCard -> askForCard
    \item \ewhile the kitchen system is in maintenance mode, \ethe kitchen system \eshall reject all input.
    % [] !hasCard -> askForCard
    \end{enumerate}
  }

\end{slide}



\section*{How to apply EARS patterns}

\begin{slide}{THE EARS PATTERNS}
  \begin{itemize}
  \item Identify whether you are working with a requirement, or something else (e.g., note, example, remark, etc)
  \item Identify compound requirements, i.e., whether the requirement needs to be split/decomposed 
  \item Identify the acting system, person, or process
  \item Analise the needed sentence type(s)
  \item Identigy possible missing requirements
  \item Analyse the translated requirements for ambiguity, conflict, and repetition
  \item Review requirements if possible
  \item Interate as required
  \end{itemize}
\end{slide}

\section*{Troubleshooting EARS problems}

\begin{frame}
  \frametitle{What are the issues that can occur when using EARS?}
  \begin{itemize}
  \item {\it No sentence type fits:} Maybe you are not translating a requirement?
  \item {\it Can't identify the actor:} either use higher abstraction level until it makes sense, or get more information from the relevant stakeholder
  \item {\it There is no system response:}  typically the case with non-functional requirements; it can be expressed as "the system shall be ..."
  \item {\it There is no template for "shall not":} try using "shall be immune" or similar or, as last resort, use the "shall not" pattern
  \item {\it EARS produces too many atomic requirements:} 
  \end{itemize}
  
\end{frame}

\section*{The Doorstop Tool}


\begin{frame}
  \frametitle{What is Doorstop?}
  \begin{block}{Motivations for Doorstop}
  \begin{itemize}
    \item Effectively managing the requirements and traceability in a complex software project can be a
challenging task
    \item Many tools exist to support the initial creation and management of changes to
text-based requirements.
    \item The most popular commercial solutions use a centralized server to host
a database with a front-end desktop or web interface
    \item {\bf }
  \end{itemize}
  
  \end{block}

   
\end{frame}

\begin{frame}
  \frametitle{What is Doorstop?}
  \begin{block}{In a Nutshell}
  \begin{itemize}
    \item Doorstop is both a Python tool and API that allows to write requirements in a text based manner and that uses version control. 
    \item This solution allows a project to utilize its existing development tools to manage versions of the requirements using a lightweight, developer-friendly interface.
  \end{itemize}
  \end{block}
  \begin{block}{How it works (high-level description)}
  \begin{itemize}
  \item When a project leverages this tool, each linkable item (requirement, test case, etc.) is stored as a YAML file in a designated directory. 
  \item The items in each directory form a document.
  \item The relationship between documents forms a tree hierarchy.
  \item Doorstop provides mechanisms for modifying this tree, validating item traceability, and publishing documents in several formats.  
  \end{itemize}

       
  \end{block}

  
\end{frame}



\end{document}
